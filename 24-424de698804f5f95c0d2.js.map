{"version":3,"file":"24-424de698804f5f95c0d2.js","mappings":"uOAGA,MACMA,EAAwB,CAACC,EAAQC,EAAOC,EAAQC,KAClD,IAAIC,EAAI,EACJC,EAAI,EACJC,EAAI,EACR,MAAMC,EALY,EAKEN,EACpB,IAAK,IAAIO,EAAI,EAAGA,EAAIP,EAAOO,IACvB,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAQO,IAAK,CAC7B,MAAMC,EAAQP,EAAcK,EAAGC,GAC/BL,GACIM,GAAQ,QAAaV,EAVf,EAUsCQ,EAAI,EAAIC,EAAIF,IAC5DF,GACIK,GAAQ,QAAaV,EAZf,EAYsCQ,EAAI,EAAIC,EAAIF,IAC5DD,GACII,GAAQ,QAAaV,EAdf,EAcsCQ,EAAI,EAAIC,EAAIF,IAGpE,IAAII,EAAQ,GAAKV,EAAQC,GACzB,MAAO,CAACE,EAAIO,EAAON,EAAIM,EAAOL,EAAIK,IAqDtC,EAvCe,CAACX,EAAQC,EAAOC,EAAQU,EAAYC,KAC/C,GAAID,EAAa,GAAKA,EAAa,GAAKC,EAAa,GAAKA,EAAa,EACnE,MAAM,IAAI,IAAgB,iDAE9B,GAAIZ,EAAQC,EAAS,IAAMF,EAAOc,OAC9B,MAAM,IAAI,IAAgB,gDAE9B,IAAIC,EAAU,GACd,IAAK,IAAIN,EAAI,EAAGA,EAAII,EAAYJ,IAC5B,IAAK,IAAID,EAAI,EAAGA,EAAII,EAAYJ,IAAK,CACjC,MAAMQ,EAAqB,GAALR,GAAe,GAALC,EAAS,EAAI,EACvCQ,EAASlB,EAAsBC,EAAQC,EAAOC,GAAQ,CAACgB,EAAGC,IAAMH,EAClEI,KAAKC,IAAKD,KAAKE,GAAKd,EAAIU,EAAKjB,GAC7BmB,KAAKC,IAAKD,KAAKE,GAAKb,EAAIU,EAAKjB,KACjCa,EAAQQ,KAAKN,GAGrB,MAAMO,EAAKT,EAAQ,GACbU,EAAKV,EAAQW,MAAM,GACzB,IAGIC,EAHAC,EAAO,GACPC,EAAWjB,EAAa,EAAuB,GAAlBC,EAAa,GAG9C,GAFAe,IAAQ,OAASC,EAAU,GAEvBJ,EAAGX,OAAS,EAAG,CACf,IAAIgB,EAAqBV,KAAKW,OAAON,EAAGO,KAAIC,GAAOb,KAAKW,OAAOE,MAC3DC,EAAwBd,KAAKe,MAAMf,KAAKW,IAAI,EAAGX,KAAKgB,IAAI,GAAIhB,KAAKe,MAA2B,IAArBL,EAA2B,OACtGH,GAAgBO,EAAwB,GAAK,IAC7CN,IAAQ,OAASM,EAAuB,QAGxCP,EAAe,EACfC,IAAQ,OAAS,EAAG,GA3CX,IAACS,EAiDd,OAJAT,IAAQ,QA7CMS,EA6CYb,IA5CT,QAAaa,EAAM,KAGhB,MAFH,QAAaA,EAAM,KAEG,IADtB,QAAaA,EAAM,KA0CL,GAC/BZ,EAAGa,SAAQrB,IACPW,IAAQ,OAzCC,EAACS,EAAOV,IAIL,GAHHP,KAAKe,MAAMf,KAAKW,IAAI,EAAGX,KAAKgB,IAAI,GAAIhB,KAAKe,MAA8C,GAAxC,QAAQE,EAAM,GAAKV,EAAc,IAAW,QAGnF,GAAc,GAFtBP,KAAKe,MAAMf,KAAKW,IAAI,EAAGX,KAAKgB,IAAI,GAAIhB,KAAKe,MAA8C,GAAxC,QAAQE,EAAM,GAAKV,EAAc,IAAW,QAC3FP,KAAKe,MAAMf,KAAKW,IAAI,EAAGX,KAAKgB,IAAI,GAAIhB,KAAKe,MAA8C,GAAxC,QAAQE,EAAM,GAAKV,EAAc,IAAW,QAsCnFY,CAAStB,EAAQU,GAAe,MAE9CC","sources":["webpack://mine/./node_modules/blurhash/dist/esm/encode.js"],"sourcesContent":["import { encode83 } from \"./base83\";\nimport { sRGBToLinear, signPow, linearTosRGB } from \"./utils\";\nimport { ValidationError } from \"./error\";\nconst bytesPerPixel = 4;\nconst multiplyBasisFunction = (pixels, width, height, basisFunction) => {\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    const bytesPerRow = width * bytesPerPixel;\n    for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n            const basis = basisFunction(x, y);\n            r +=\n                basis * sRGBToLinear(pixels[bytesPerPixel * x + 0 + y * bytesPerRow]);\n            g +=\n                basis * sRGBToLinear(pixels[bytesPerPixel * x + 1 + y * bytesPerRow]);\n            b +=\n                basis * sRGBToLinear(pixels[bytesPerPixel * x + 2 + y * bytesPerRow]);\n        }\n    }\n    let scale = 1 / (width * height);\n    return [r * scale, g * scale, b * scale];\n};\nconst encodeDC = (value) => {\n    const roundedR = linearTosRGB(value[0]);\n    const roundedG = linearTosRGB(value[1]);\n    const roundedB = linearTosRGB(value[2]);\n    return (roundedR << 16) + (roundedG << 8) + roundedB;\n};\nconst encodeAC = (value, maximumValue) => {\n    let quantR = Math.floor(Math.max(0, Math.min(18, Math.floor(signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))));\n    let quantG = Math.floor(Math.max(0, Math.min(18, Math.floor(signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))));\n    let quantB = Math.floor(Math.max(0, Math.min(18, Math.floor(signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))));\n    return quantR * 19 * 19 + quantG * 19 + quantB;\n};\nconst encode = (pixels, width, height, componentX, componentY) => {\n    if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {\n        throw new ValidationError(\"BlurHash must have between 1 and 9 components\");\n    }\n    if (width * height * 4 !== pixels.length) {\n        throw new ValidationError(\"Width and height must match the pixels array\");\n    }\n    let factors = [];\n    for (let y = 0; y < componentY; y++) {\n        for (let x = 0; x < componentX; x++) {\n            const normalisation = x == 0 && y == 0 ? 1 : 2;\n            const factor = multiplyBasisFunction(pixels, width, height, (i, j) => normalisation *\n                Math.cos((Math.PI * x * i) / width) *\n                Math.cos((Math.PI * y * j) / height));\n            factors.push(factor);\n        }\n    }\n    const dc = factors[0];\n    const ac = factors.slice(1);\n    let hash = \"\";\n    let sizeFlag = componentX - 1 + (componentY - 1) * 9;\n    hash += encode83(sizeFlag, 1);\n    let maximumValue;\n    if (ac.length > 0) {\n        let actualMaximumValue = Math.max(...ac.map(val => Math.max(...val)));\n        let quantisedMaximumValue = Math.floor(Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5))));\n        maximumValue = (quantisedMaximumValue + 1) / 166;\n        hash += encode83(quantisedMaximumValue, 1);\n    }\n    else {\n        maximumValue = 1;\n        hash += encode83(0, 1);\n    }\n    hash += encode83(encodeDC(dc), 4);\n    ac.forEach(factor => {\n        hash += encode83(encodeAC(factor, maximumValue), 2);\n    });\n    return hash;\n};\nexport default encode;\n//# sourceMappingURL=encode.js.map"],"names":["multiplyBasisFunction","pixels","width","height","basisFunction","r","g","b","bytesPerRow","x","y","basis","scale","componentX","componentY","length","factors","normalisation","factor","i","j","Math","cos","PI","push","dc","ac","slice","maximumValue","hash","sizeFlag","actualMaximumValue","max","map","val","quantisedMaximumValue","floor","min","value","forEach","encodeAC"],"sourceRoot":""}