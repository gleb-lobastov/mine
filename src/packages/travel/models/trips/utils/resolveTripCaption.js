import dateMin from 'date-fns/min';
import dateMax from 'date-fns/max';
import groupBy from 'lodash/groupBy';
import uniqTrimAndJoin from 'modules/utilities/text/uniqTrimAndJoin';
import { VISIT_TYPES } from 'travel/models/visits/consts';
import { visitDateTimePeriodToString } from 'modules/utilities/dateTime/dateTimePeriodToString';

const FALLBACK = 'Без названия';
export default function resolveTripCaption(
  trip,
  visitsDict,
  countriesDict,
  locationsDict,
) {
  const {
    visits: visitsIds,
    originLocationId,
    tripName,
    hasAutogeneratedTripName,
  } = trip || {};

  const originCountryId = locationsDict[originLocationId]?.countryId;

  if (!hasAutogeneratedTripName) {
    return tripName || FALLBACK;
  }
  if (!visitsIds.length) {
    return FALLBACK;
  }

  const periodStr = visitDateTimePeriodToString({
    arrivalDateTime: dateMin(
      visitsIds.map(visitsId => visitsDict[visitsId]?.arrivalDateTime),
    ),
    departureDateTime: dateMax(
      visitsIds.map(visitsId => visitsDict[visitsId]?.departureDateTime),
    ),
  });

  const visitsByCountries = Object.keys(
    groupBy(
      visitsIds.filter(
        visitId => visitsDict[visitId]?.visitType !== VISIT_TYPES.TRANSIT,
      ),
      'countryId',
    ),
  );

  if (visitsByCountries.length === 1) {
    const locationsNames = uniqTrimAndJoin(
      visitsIds.map(visitId => visitsDict[visitId]?.locationName),
      { maxLength: 4 },
    );
    return `${locationsNames || FALLBACK}, ${periodStr}`;
  }

  const countriesNames = uniqTrimAndJoin(
    visitsByCountries
      .map(
        countryId =>
          Number(countryId) !== originCountryId &&
          countriesDict[countryId] &&
          countriesDict[countryId].countryName,
      )
      .filter(Boolean),
    { maxLength: 4 },
  );
  return `${countriesNames || FALLBACK}, ${periodStr}`;
}
